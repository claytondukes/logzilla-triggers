This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
cisco_device_manager.py
compliance.py
compose.yml
docker-compose.slack.yml
Dockerfile
Dockerfile.slackbot
requirements.txt
script_server.yaml
slack_notifier.py
slack_server.py
slack-app-manifest.yaml
update_ngrok_url.sh
utils.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="cisco_device_manager.py">
#!/usr/bin/env python3
"""
Cisco device management module for LogZilla Network Event Orchestrator.

Provides classes and functions for interacting with Cisco devices.
"""

import re
import socket
import logging
import subprocess
import traceback
from netmiko import ConnectHandler, NetmikoTimeoutException, NetmikoAuthenticationException

# Constants
DEFAULT_TIMEOUT = 10

class CiscoDeviceManager:
    """Manage Cisco device connections and operations."""
    
    def __init__(self, username, password, timeout=DEFAULT_TIMEOUT):
        """
        Initialize with device credentials.
        
        Args:
            username (str): Cisco device username.
            password (str): Cisco device password.
            timeout (int): Connection timeout in seconds.
        """
        self.username = username
        self.password = password
        self.timeout = timeout
        self.device = None
    
    def connect(self, host):
        """
        Connect to a Cisco device.
        
        Args:
            host (str): Device IP address or hostname.
            
        Returns:
            bool: True if connection is successful, False otherwise.
            
        Raises:
            NetmikoTimeoutException: If connection times out.
            NetmikoAuthenticationException: If authentication fails.
        """
        logging.info(f"Attempting to connect to: {host}")
        
        device_params = {
            'device_type': 'cisco_ios',
            'host': host,
            'username': self.username,
            'password': self.password,
            'timeout': self.timeout
        }
        
        try:
            # Try to connect with Netmiko
            self.device = ConnectHandler(**device_params)
            return True
        except NetmikoTimeoutException as e:
            # Enhanced error detail - perform network diagnostics
            error_details = self._run_diagnostics(host)
            error_msg = f"TCP connection to device {host} failed: {str(e)}\n\n{error_details}"
            raise NetmikoTimeoutException(error_msg) from e
        except NetmikoAuthenticationException as e:
            error_msg = f"Authentication to device {host} failed: {str(e)}"
            raise NetmikoAuthenticationException(error_msg) from e
        except Exception as e:
            error_msg = f"Unknown connection error to {host}: {str(e)}"
            logging.error(error_msg)
            logging.error(traceback.format_exc())
            raise
    
    def _run_diagnostics(self, host):
        """
        Run network diagnostics on host to gather more information about connection failures.
        
        Args:
            host (str): Target host to diagnose
            
        Returns:
            str: Diagnostic information
        """
        diagnostic_info = ["Diagnostic Information:"]
        
        # Check if host is reachable with ping
        try:
            ping_result = subprocess.run(
                ["ping", "-c", "3", "-W", "2", host],
                capture_output=True,
                text=True,
                timeout=5
            )
            if ping_result.returncode == 0:
                diagnostic_info.append(f"✅ Host {host} is reachable via ICMP (ping)")
            else:
                diagnostic_info.append(f"❌ Host {host} is NOT reachable via ICMP (ping)")
                diagnostic_info.append(f"Ping output: {ping_result.stdout}")
        except Exception as e:
            diagnostic_info.append(f"⚠️ Unable to run ping test: {str(e)}")
        
        # Check if SSH port is open
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(3)
                result = s.connect_ex((host, 22))
                if result == 0:
                    diagnostic_info.append(f"✅ SSH port (22) on {host} is open")
                else:
                    diagnostic_info.append(f"❌ SSH port (22) on {host} is closed or filtered (error code: {result})")
        except Exception as e:
            diagnostic_info.append(f"⚠️ Unable to check SSH port: {str(e)}")
            
        # Check network route
        try:
            traceroute_result = subprocess.run(
                ["traceroute", "-n", "-w", "2", "-m", "10", host],
                capture_output=True,
                text=True,
                timeout=10
            )
            if traceroute_result.returncode == 0:
                route_output = traceroute_result.stdout.strip()
                diagnostic_info.append(f"Network route to {host}:\n{route_output}")
            else:
                diagnostic_info.append(f"❌ Traceroute to {host} failed")
        except Exception as e:
            diagnostic_info.append(f"⚠️ Unable to run traceroute: {str(e)}")
            
        return "\n".join(diagnostic_info)
    
    def disconnect(self):
        """Safely disconnect from the device if connected."""
        if self.device and self.device.is_alive():
            self.device.disconnect()
            
    def bring_interface_up(self, device, interface):
        """
        Connect to a device and bring up an interface.
        
        Args:
            device (str): Device hostname or IP address.
            interface (str): Interface name to bring up.
            
        Returns:
            bool: True if the operation was successful, False otherwise.
        """
        try:
            # Connect to the device
            if not self.connect(device):
                logging.error(f"Failed to connect to {device}")
                return False
                
            # Send the no shutdown command
            result = self.configure_interface(interface, "no shutdown")
            
            # Disconnect after the operation
            self.disconnect()
            
            return result
        except Exception as e:
            logging.error(f"Error bringing up interface {interface} on {device}: {e}")
            # Ensure we disconnect even if there was an error
            self.disconnect()
            return False
    
    def configure_interface(self, interface, command):
        """
        Configure an interface on the connected device.
        
        Args:
            interface (str): Interface name.
            command (str): Command to apply to the interface.
            
        Returns:
            bool: True if configuration was successful, False otherwise.
        """
        try:
            config_commands = [
                f"interface {interface}",
                command,
                "exit"
            ]
            output = self.device.send_config_set(config_commands)
            logging.info(f"Configuration output:\n{output}")
            return True
        except Exception as e:
            logging.error(f"Failed to configure interface: {str(e)}")
            return False
    
    def get_interface_description(self, interface):
        """
        Get the description of an interface.
        
        Args:
            interface (str): Interface name.
            
        Returns:
            str: Interface description or "No description found".
        """
        output = self.device.send_command(f"show interface {interface} | include Description")
        return self._extract_interface_description(output)
    
    def _extract_interface_description(self, output):
        """
        Extract description from interface output.
        
        Args:
            output (str): Command output.
            
        Returns:
            str: Description or empty string.
        """
        if not output:
            return ""
        
        # Try to match "Description: <text>" format
        match = re.search(r"Description: (.+)", output)
        if match:
            return match.group(1).strip()
            
        return ""
    
    @staticmethod
    def parse_interface_event(event_message):
        """
        Parse interface and state from an event message.
        
        Args:
            event_message (str): Event message to parse.
            
        Returns:
            tuple: (interface_name, state) or (None, None) if parsing fails.
        """
        if not event_message:
            return None, None
        
        logging.debug(f"Parsing event message: {event_message}")
        
        # Check if the interface is reported as down
        match_down = re.search(r"Interface (\S+), changed state to down", event_message)
        if match_down:
            return match_down.group(1), "down"
        
        # Check if the interface is reported as up
        match_up = re.search(r"Interface (\S+), changed state to up", event_message)
        if match_up:
            return match_up.group(1), "up"
        
        return None, None
</file>

<file path="compliance.py">
#!/usr/bin/env python3
"""
Main application module for Cisco interface compliance.

Provides the ComplianceApplication class that orchestrates the entire workflow.
Includes Flask server for Slack interactive buttons.
"""

import os
import sys
import logging
import json
import threading
from flask import Flask, request, Response

# Import from local modules
from utils import LoggingConfigurator, ConfigLoader, NetworkUtils
from slack_notifier import SlackNotifier, SLACK_COLOR_DANGER, SLACK_COLOR_SUCCESS
from slack_notifier import SLACK_EMOJI_DOWN, SLACK_EMOJI_UP, STATUS_DOWN, STATUS_UP
from cisco_device_manager import CiscoDeviceManager, DEFAULT_TIMEOUT
from netmiko import NetmikoTimeoutException, NetmikoAuthenticationException

# Constants for Slack verification
SLACK_VERIFY_TOKEN = os.getenv("SLACK_VERIFY_TOKEN", "")  # For simple verification

# Initialize Flask app
app = Flask(__name__)

# Global reference to the ComplianceApplication instance
# (will be set in the main block)
compliance_app = None


class ComplianceApplication:
    """Main application class for Cisco interface compliance."""
    
    def __init__(self):
        """Initialize the application."""
        # Set up logging
        LoggingConfigurator.setup_logging()
        
        # Optionally print environment variables for debugging
        if logging.getLogger().getEffectiveLevel() <= logging.DEBUG:
            self._print_environment_variables()
        
        # Load configuration
        self.config = ConfigLoader.load_config('/scripts/config.yaml')
        
        # Initialize components
        self.slack = SlackNotifier(
            webhook_url=self.config['posturl'],
            timeout=self.config.get('timeout', DEFAULT_TIMEOUT),
            channel=self.config.get('default_channel', '#general')
        )
        
        self.cisco_manager = CiscoDeviceManager(
            username=self.config['ciscoUsername'],
            password=self.config['ciscoPassword'],
            timeout=self.config.get('timeout', DEFAULT_TIMEOUT)
        )
    
    def _print_environment_variables(self):
        """Print all EVENT_ environment variables if debugging is enabled."""
        logging.debug("Incoming Event Variables:")
        for key, value in os.environ.items():
            if key.startswith("EVENT"):
                logging.debug(f"{key} = {value}")
    
    def run(self):
        """Run the main application logic."""
        event_host_ip = None
        try:
            # Get and resolve hostname
            event_host = os.environ.get('EVENT_HOST', self.config.get('EVENT_HOST', ''))
            logging.debug(f"Original EVENT_HOST: {event_host}")
            
            # Resolve hostname to IP
            event_host_ip = NetworkUtils.resolve_host(event_host, self.config)
            
            # Connect to the device
            self.cisco_manager.connect(event_host_ip)
            
            # Process the event message
            event_message = os.environ.get('EVENT_MESSAGE', '')
            interface, state = self.cisco_manager.parse_interface_event(event_message)
            
            if not interface:
                logging.error("Unable to obtain interface name from event message")
                sys.exit(1)
            
            logging.debug(f"Detected interface: {interface}, state: {state}")
            
            # Get interface description
            description = self.cisco_manager.get_interface_description(interface)
            logging.debug(f"Interface Description: {description}")
            
            # Handle interface state
            self._handle_interface_state(
                event_host, 
                interface, 
                state, 
                description, 
                event_message
            )
            
        except (NetmikoTimeoutException, NetmikoAuthenticationException) as e:
            logging.error(f"Netmiko error occurred: {str(e)}")
            logging.exception("Exception details:")
            
            # Send enhanced error notification with more details
            error_message = str(e)
            formatted_error = f"ERROR: {error_message}\n\nDevice settings: {event_host_ip}:{self.config.get('port', '22')}"
            
            self.slack.send_error_notification(event_host, formatted_error)
            
        finally:
            # Ensure we disconnect cleanly
            self.cisco_manager.disconnect()
    
    def _handle_interface_state(self, event_host, interface, state, description, event_message):
        """
        Handle interface state changes.
        
        Args:
            event_host (str): Device hostname.
            interface (str): Interface name.
            state (str): Interface state ("up" or "down").
            description (str): Interface description.
            event_message (str): Original event message.
        """
        mnemonic = os.environ.get('EVENT_CISCO_MNEMONIC', '')
        
        if state == "down":
            # Check if we should add interactive buttons
            use_interactive_buttons = self.config.get('use_interactive_buttons', False)
            ngrok_url = self.config.get('ngrok_url', '')
            
            # Send notification that the interface is down
            self.slack.send_interface_notification(
                event_host, interface, "down", description, event_message,
                STATUS_DOWN, SLACK_EMOJI_DOWN, SLACK_COLOR_DANGER, mnemonic,
                use_interactive_buttons=use_interactive_buttons,
                ngrok_url=ngrok_url
            )
            
            # Bring the interface back up if configured to do so and not using buttons
            if self.config.get('bring_interface_up', True) and not use_interactive_buttons:
                logging.info(f"Action: Bringing interface {interface} back up")
                if self.cisco_manager.configure_interface(interface, "no shutdown"):
                    logging.info(f"Success: Interface {interface} should be coming back up")
                
        elif state == "up":
            # Send notification that the interface is up
            self.slack.send_interface_notification(
                event_host, interface, "up", description, event_message,
                STATUS_UP, SLACK_EMOJI_UP, SLACK_COLOR_SUCCESS, mnemonic
            )


# Flask routes for Slack interactive buttons
@app.route('/slack/actions', methods=['POST'])
def slack_actions():
    """Handle Slack interactive button actions."""
    request_body = request.get_data()
    logging.info(f"Received Slack action request: {request_body}")
    
    # Simple token verification (can be enhanced with signing secrets)
    if SLACK_VERIFY_TOKEN and request.headers.get('X-Slack-Verification-Token') != SLACK_VERIFY_TOKEN:
        logging.warning("Invalid Slack verification token")
        return Response("Unauthorized", status=401)
    
    # Parse the payload
    try:
        payload = json.loads(request.form.get('payload', '{}'))
        logging.info(f"Parsed payload: {payload}")
    except Exception as e:
        logging.error(f"Failed to parse payload: {e}")
        return Response("Invalid payload format", status=400)
    
    # Extract action data
    actions = payload.get('actions', [])
    if not actions:
        logging.error("No action found in payload")
        return Response("No action found", status=400)
    
    action = actions[0]
    action_id = action.get('action_id', '')
    value = action.get('value', '')
    response_url = payload.get('response_url', '')
    
    logging.info(f"Processing action_id: {action_id}, value: {value}")
    
    # Validate value format
    try:
        device, interface = value.split('|')
    except ValueError:
        logging.error(f"Invalid value format: {value}")
        return Response("Invalid value format", status=400)
    
    # Handle different action types
    if action_id == "fix_interface":
        return handle_fix_interface(device, interface, response_url)
    elif action_id == "acknowledge":
        return handle_acknowledge(device, interface, response_url)
    
    return Response("Unknown action", status=400)


def handle_fix_interface(device, interface, response_url):
    """Handle fix interface action."""
    logging.info(f"Fixing interface {interface} on {device}")
    
    try:
        # Get IP address for device
        device_ip = NetworkUtils.resolve_host(device, compliance_app.config)
        
        # Connect to the device
        cisco_manager = compliance_app.cisco_manager
        cisco_manager.connect(device_ip)
        
        # Configure the interface
        success = cisco_manager.configure_interface(interface, "no shutdown")
        
        # Send response back to Slack
        if success:
            message = f"✅ Successfully brought interface {interface} up on {device}"
            response = {
                "text": message,
                "replace_original": False,
                "response_type": "in_channel"
            }
            compliance_app.slack.post_update_to_slack(response_url, response)
        else:
            message = f"❌ Failed to bring interface {interface} up on {device}"
            response = {
                "text": message,
                "replace_original": False,
                "response_type": "in_channel"
            }
            compliance_app.slack.post_update_to_slack(response_url, response)
            
        return Response("Processing", status=200)
        
    except Exception as e:
        logging.error(f"Error fixing interface: {e}")
        error_response = {
            "text": f"❌ Error fixing interface {interface} on {device}: {str(e)}",
            "replace_original": False,
            "response_type": "in_channel"
        }
        compliance_app.slack.post_update_to_slack(response_url, error_response)
        return Response("Error processing", status=500)


def handle_acknowledge(device, interface, response_url):
    """Handle acknowledge action."""
    logging.info(f"Acknowledging interface {interface} issue on {device}")
    
    try:
        message = f"👍 Alert for interface {interface} on {device} has been acknowledged"
        response = {
            "text": message,
            "replace_original": False,
            "response_type": "in_channel"
        }
        compliance_app.slack.post_update_to_slack(response_url, response)
        return Response("Acknowledged", status=200)
    except Exception as e:
        logging.error(f"Error acknowledging alert: {e}")
        return Response("Error processing", status=500)


def run_flask_server():
    """Run the Flask server in a separate thread."""
    port = int(os.environ.get('PORT', 8000))  
    debug = os.environ.get('FLASK_DEBUG', '0') == '1'
    logging.info(f"Starting Flask server on port {port} for Slack interactive buttons")
    app.run(host='0.0.0.0', port=port, debug=debug, use_reloader=False)


if __name__ == "__main__":
    # Initialize the compliance application
    compliance_app = ComplianceApplication()
    
    # Start Flask server in a separate thread
    flask_thread = threading.Thread(target=run_flask_server)
    flask_thread.daemon = True
    flask_thread.start()
    
    # Log the Flask server startup
    port = int(os.environ.get('PORT', 8000))
    logging.info(f"Starting Flask server on port {port}")
    
    # Run the main compliance application
    compliance_app.run()
</file>

<file path="compose.yml">
services:
  api:
    build:
      context: .
    container_name: compliance-script-server
    environment:
      - CONFIG_FILE=/scripts/config.yaml
      - SCRIPTS_DIR=/scripts
      - SCRIPTS_LOGS_DIR=/var/log/logzilla/scripts
      - PORT=8000
      - FLASK_DEBUG=0
      - SLACK_VERIFY_TOKEN=${SLACK_VERIFY_TOKEN:-}
    command: python /scripts/compliance.py
    ports:
      - "127.0.0.1:8081:8000"
    volumes:
        - ./compliance.py:/scripts/compliance.py
        - ./app.py:/scripts/app.py
        - ./slack_notifier.py:/scripts/slack_notifier.py
        - ./cisco_device_manager.py:/scripts/cisco_device_manager.py
        - ./utils.py:/scripts/utils.py
        - ./config.yaml:/scripts/config.yaml
        - /var/log/logzilla/scripts:/var/log/logzilla/scripts
    networks:
      - lz_network
    restart: always
    
  ngrok:
    image: ngrok/ngrok
    container_name: ngrok
    environment:
      - NGROK_AUTHTOKEN=${NGROK_AUTHTOKEN}
    command: http compliance-script-server:8000 --domain=logzilla.ngrok.io --log=stdout --log-format=json
    networks:
      - lz_network
    stdin_open: true
    tty: true
    volumes:
      - /var/log/ngrok.log:/var/log/ngrok.log
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    restart: always

networks:
  lz_network:
    name: lz_main
    external: true
</file>

<file path="docker-compose.slack.yml">
version: '3'

services:
  slackbot:
    build:
      context: .
      dockerfile: Dockerfile.slackbot
    container_name: slackbot-server
    environment:
      - PORT=8080
      - FLASK_DEBUG=0
      - SLACK_VERIFY_TOKEN=${SLACK_VERIFY_TOKEN:-}
      - CONFIG_FILE=/app/config.yaml
    ports:
      - "127.0.0.1:8080:8080"
    volumes:
      - ./slack_server.py:/app/slack_server.py
      - ./slack_notifier.py:/app/slack_notifier.py
      - ./cisco_device_manager.py:/app/cisco_device_manager.py
      - ./utils.py:/app/utils.py
      - ./config.yaml:/app/config.yaml
    networks:
      - slackbot_network
    restart: always
    
  ngrok:
    image: ngrok/ngrok:latest
    container_name: slackbot-ngrok
    environment:
      - NGROK_AUTHTOKEN=${NGROK_AUTHTOKEN}
    command: http slackbot-server:8080 --domain=logzilla.ngrok.io --log=stdout --log-format=json
    networks:
      - slackbot_network
    ports:
      - "4040:4040"  # Expose ngrok web UI
    stdin_open: true
    tty: true
    depends_on:
      - slackbot

networks:
  slackbot_network:
    driver: bridge
</file>

<file path="Dockerfile">
# Use a logzilla script-server base image
FROM logzilla/script-server:latest

# Copy the requirements.txt file to the container
COPY requirements.txt /tmp/requirements.txt

# Install Python dependencies
RUN pip install -r /tmp/requirements.txt \
    --no-cache-dir --break-system-packages --root-user-action=ignore

# Create scripts directory
RUN mkdir -p /scripts
RUN mkdir -p /var/log/logzilla/scripts
</file>

<file path="Dockerfile.slackbot">
FROM python:3.9-slim

WORKDIR /app

# Copy requirements
COPY requirements.txt .

# Install dependencies
RUN pip install --no-cache-dir -r requirements.txt
RUN pip install gunicorn flask requests pyyaml netmiko

# Set environment variables
ENV PORT=8080
ENV FLASK_DEBUG=0

# Copy application files
COPY slack_server.py .
COPY slack_notifier.py .
COPY cisco_device_manager.py .
COPY utils.py .
COPY config.yaml .

EXPOSE 8080

# Run the server
CMD ["python", "slack_server.py"]
</file>

<file path="requirements.txt">
paramiko
requests
pyyaml
netmiko
flask
</file>

<file path="script_server.yaml">
---
SERVERS:
  - name: custom
    url: http://compliance-script-server:8000/scripts
</file>

<file path="slack_notifier.py">
#!/usr/bin/env python3
"""
Slack notification module for LogZilla Network Event Orchestrator.

Provides classes and functions for sending notifications to Slack.
"""

import os
import json
import time
import logging
import requests

# Constants
SLACK_COLOR_DANGER = "#9C1A22"  # Red color for down status
SLACK_COLOR_SUCCESS = "#008000"  # Green color for up status
SLACK_EMOJI_DOWN = "🔴"
SLACK_EMOJI_UP = "🟢"
STATUS_DOWN = "DOWN"
STATUS_UP = "RECOVERED"
DEFAULT_TIMEOUT = 10

class SlackNotifier:
    """Send notifications to Slack."""
    
    def __init__(self, webhook_url, timeout=DEFAULT_TIMEOUT, channel=None):
        """
        Initialize with Slack webhook URL or bot token.
        
        Args:
            webhook_url (str): Slack webhook URL or bot token.
            timeout (int): Request timeout in seconds.
            channel (str): Default channel to post to when using bot tokens.
        """
        self.webhook_url = webhook_url
        self.timeout = timeout
        self.channel = channel
        
        # Determine if using bot token or webhook URL
        self.using_bot_token = webhook_url.startswith('xoxb-') if webhook_url else False
        
        if self.using_bot_token:
            logging.info("Using Slack Bot token for notifications (supports interactive components)")
        else:
            logging.info("Using Slack webhook URL for notifications (limited interactivity support)")
    
    def send_interface_notification(self, event_host, interface, state, 
                               description, event_message, status, 
                               emoji, color, mnemonic, 
                               use_interactive_buttons=False, ngrok_url=""):
        """
        Send interface status notification to Slack.
        
        Args:
            event_host (str): Device hostname.
            interface (str): Interface name.
            state (str): Interface state (up/down).
            description (str): Interface description.
            event_message (str): Original event message.
            status (str): Status string for the message (UP/DOWN).
            emoji (str): Emoji to use in the message.
            color (str): Color for the Slack attachment.
            mnemonic (str): Cisco mnemonic associated with the event.
            use_interactive_buttons (bool): Whether to include interactive buttons.
            ngrok_url (str): URL for ngrok tunnel for button callbacks.
            
        Returns:
            bool: True if notification was sent successfully, False otherwise.
        """
        logging.info(f"Sending notification for {interface} {state} on {event_host}")
        
        # Format the timestamp
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        
        # Get the severity if available
        severity = os.environ.get('EVENT_SEVERITY', '5')
        severity_text = f"Severity {severity}" if severity else ""
        
        # Enhanced header with status badge
        status_display = f"{emoji} {status}"
        
        # Network status icon based on state
        network_icon = "🔌" if state == "down" else "⚡"
        device_icon = "🖧" if "router" in event_host.lower() else "🖥️"
        
        # Create blocks for the message with enhanced formatting
        blocks = [
            # Banner header with eye-catching design
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": f"{status_display}: Interface {interface} on {event_host}"
                }
            },
            
            # Divider for visual separation
            {"type": "divider"},
            
            # Main information section with enhanced icons
            {
                "type": "section",
                "fields": [
                    {
                        "type": "mrkdwn",
                        "text": f"*Device:* {device_icon}\n{event_host}"
                    },
                    {
                        "type": "mrkdwn",
                        "text": f"*Interface:* {network_icon}\n{interface}"
                    }
                ]
            },
            
            # Status information with visual indicators
            {
                "type": "section",
                "fields": [
                    {
                        "type": "mrkdwn",
                        "text": f"*State:* {emoji}\n{state.upper()}"
                    },
                    {
                        "type": "mrkdwn",
                        "text": "*Description:*\n" + (description if description else "No description found")
                    }
                ]
            }
        ]
        
        # Add program and severity with enhanced formatting
        program_fields = []
        if True:  # Always show program info
            program_fields.append({
                "type": "mrkdwn",
                "text": "*Program:* 📟\nCisco"
            })
        
        if severity:
            # Visual severity indicator
            severity_icon = "🔥" if int(severity) <= 3 else "⚠️" if int(severity) <= 5 else "ℹ️"
            program_fields.append({
                "type": "mrkdwn",
                "text": f"*Severity:* {severity_icon}\n{severity}/10"
            })
            
        if program_fields:
            blocks.append({
                "type": "section",
                "fields": program_fields
            })
        
        # Add the event message with enhanced code block formatting
        blocks.append({"type": "divider"})
        
        blocks.append({
            "type": "section",
            "text": {
                "type": "mrkdwn",
                "text": "*Event Message:* 📋"
            }
        })
        
        blocks.append({
            "type": "section",
            "text": {
                "type": "mrkdwn",
                "text": f"```{event_message}```"
            }
        })
        
        # Add interactive buttons with enhanced visibility if requested
        if use_interactive_buttons and state == "down" and ngrok_url:
            # Make sure the ngrok URL ends with a slash
            if not ngrok_url.endswith("/"):
                ngrok_url += "/"
            
            # Add a divider to make buttons more prominent
            blocks.append({"type": "divider"})
            
            # Add a section explaining the available actions
            blocks.append({
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": "*Available Actions:* 🛠️"
                }
            })
                
            # Add action buttons section with enhanced styling
            blocks.append({
                "type": "actions",
                "elements": [
                    {
                        "type": "button",
                        "text": {
                            "type": "plain_text",
                            "text": "🔄 Fix Interface",
                            "emoji": True
                        },
                        "style": "primary",
                        "value": f"{event_host}|{interface}",
                        "action_id": "fix_interface"
                    },
                    {
                        "type": "button",
                        "text": {
                            "type": "plain_text",
                            "text": "✅ Acknowledge",
                            "emoji": True
                        },
                        "value": f"{event_host}|{interface}",
                        "action_id": "acknowledge"
                    }
                ]
            })
            
            logging.info(f"Added interactive buttons with ngrok URL: {ngrok_url}slack/actions")
        
        # Add timestamp and event ID in a footer-like context
        blocks.append({"type": "divider"})
        
        footer_elements = [
            {
                "type": "mrkdwn",
                "text": f"🕒 *Time:* {timestamp}"
            }
        ]
        
        if mnemonic:
            footer_elements.append({
                "type": "mrkdwn",
                "text": f"🔖 *Event:* {mnemonic}"
            })
        
        blocks.append({
            "type": "context",
            "elements": footer_elements
        })
        
        # Add LogZilla branding
        blocks.append({
            "type": "context",
            "elements": [
                {
                    "type": "mrkdwn",
                    "text": "Powered by LogZilla Network Event Orchestrator"
                }
            ]
        })
        
        # Prepare the payload with the enhanced blocks
        payload = {
            "attachments": [
                {
                    "color": color,
                    "blocks": blocks
                }
            ]
        }
        
        return self._send_payload(payload)
    
    def send_error_notification(self, event_host, error_message):
        """
        Send error notification to Slack.
        
        Args:
            event_host (str): Device hostname.
            error_message (str): Error message.
            
        Returns:
            bool: True if notification was sent successfully, False otherwise.
        """
        logging.info(f"Sending error notification for {event_host}")
        
        # Format the timestamp
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        
        # Get troubleshooting tips
        tips = self._get_troubleshooting_tips(error_message)
        
        # Create blocks for the message with enhanced formatting
        blocks = [
            # Header
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": f"⚠️ Error connecting to {event_host}"
                }
            },
            
            # Divider
            {"type": "divider"},
            
            # Error information
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": f"*Error Message:*\n```{error_message}```"
                }
            }
        ]
        
        # Add troubleshooting tips if available
        if tips:
            blocks.append({
                "type": "section", 
                "text": {
                    "type": "mrkdwn",
                    "text": f"*Troubleshooting Tips:*\n{tips}"
                }
            })
        
        # Add timestamp in a footer
        blocks.append({"type": "divider"})
        
        blocks.append({
            "type": "context",
            "elements": [
                {
                    "type": "mrkdwn",
                    "text": f"🕒 *Time:* {timestamp}"
                }
            ]
        })
        
        # Prepare the payload
        payload = {
            "attachments": [
                {
                    "color": SLACK_COLOR_DANGER,
                    "blocks": blocks
                }
            ]
        }
        
        return self._send_payload(payload)
    
    def _get_troubleshooting_tips(self, error_message):
        """
        Generate troubleshooting tips based on the error message.
        
        Args:
            error_message (str): The error message to analyze
            
        Returns:
            str: Relevant troubleshooting tips
        """
        tips = []
        
        # Check for common error patterns and add tips
        if "timed out" in error_message.lower():
            tips.append("• Check if the device is reachable (ping)")
            tips.append("• Verify SSH service is running on the device")
            tips.append("• Check network connectivity and firewall rules")
            
        elif "authentication failed" in error_message.lower():
            tips.append("• Verify username and password are correct")
            tips.append("• Check if the account is locked or disabled")
            
        elif "connection refused" in error_message.lower():
            tips.append("• Verify SSH service is running on port 22")
            tips.append("• Check firewall settings on the device")
            
        # Always include these general tips if we don't have specific ones
        if not tips:
            tips.append("• Verify network connectivity to the device")
            tips.append("• Check credentials in the configuration")
            tips.append("• Ensure SSH access is enabled on the device")
            
        return "\n".join(tips)
    
    def post_update_to_slack(self, response_url, payload):
        """
        Post an update to Slack using response_url from interactive button actions.
        
        Args:
            response_url (str): Slack response URL for interactive messages
            payload (dict): Message payload
            
        Returns:
            bool: True if successful, False otherwise.
        """
        try:
            headers = {
                "Content-Type": "application/json"
            }
            
            response = requests.post(
                response_url,
                json=payload,
                headers=headers,
                timeout=self.timeout
            )
            
            if response.status_code != 200:
                logging.error(
                    f"Request to Slack response URL returned an error {response.status_code}, "
                    f"the response is:\n{response.text}"
                )
                return False
            
            logging.info("Successfully posted update to Slack")
            return True
            
        except Exception as e:
            logging.error(f"Error posting update to Slack: {str(e)}")
            logging.exception("Exception details:")
            return False
    
    def _send_payload(self, payload):
        """
        Send payload to Slack using either webhook URL or bot token.
        
        Args:
            payload (dict): Message payload.
            
        Returns:
            bool: True if successful, False otherwise.
        """
        try:
            if self.using_bot_token:
                # When using a bot token, we need to use the Slack Web API
                # Get the channel from the config or use default
                channel = payload.get('channel', self.channel or '#general')
                
                # Prepare the headers for Slack Web API
                headers = {
                    'Content-Type': 'application/json; charset=utf-8',
                    'Authorization': f'Bearer {self.webhook_url}'
                }
                
                # Extract blocks and attachments from the payload
                api_payload = {
                    'channel': channel,
                    'text': payload.get('text', 'Notification from LogZilla')
                }
                
                # Add attachments if present
                if 'attachments' in payload:
                    api_payload['attachments'] = payload['attachments']
                
                # Send to the Slack chat.postMessage API endpoint
                response = requests.post(
                    'https://slack.com/api/chat.postMessage',
                    json=api_payload,
                    headers=headers,
                    timeout=self.timeout,
                    verify=True
                )
                
                response_data = response.json()
                if not response_data.get('ok', False):
                    logging.error(
                        f"Request to Slack API returned an error: "
                        f"{response_data.get('error', 'Unknown error')}"
                    )
                    return False
            else:
                # Traditional webhook approach
                response = requests.post(
                    self.webhook_url, 
                    json=payload, 
                    timeout=self.timeout, 
                    verify=True
                )
                
                if response.status_code != 200:
                    logging.error(
                        f"Request to Slack webhook returned an error {response.status_code}, "
                        f"the response is:\n{response.text}"
                    )
                    return False
            
            logging.info("Successfully posted to Slack")
            logging.debug(json.dumps(payload))
            return True
            
        except Exception as e:
            logging.error(f"Error sending notification to Slack: {str(e)}")
            logging.exception("Exception details:")
            return False
</file>

<file path="slack_server.py">
#!/usr/bin/env python3
"""
Slack Interactive Button Handler for LogZilla Cisco Interface Compliance

This server handles Slack button interactions for bringing down interfaces back up.
It works alongside the main compliance.py script but focuses on the interactive part.

Version: 1.0.0
Author: LogZilla Team
"""

import os
import sys
import json
import yaml
import logging
import hmac
import hashlib
from flask import Flask, request, Response
from slack_notifier import SlackNotifier
from cisco_device_manager import CiscoDeviceManager

# Constants
CONFIG_FILE = os.getenv("CONFIG_FILE", "config.yaml")
DEFAULT_TIMEOUT = 10
SLACK_SUCCESS_COLOR = "#008000"  # Green
SLACK_ERROR_COLOR = "#9C1A22"    # Red
SLACK_VERIFY_TOKEN = os.getenv("SLACK_VERIFY_TOKEN", "")  # For simple verification

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s %(levelname)s %(message)s')
logger = logging.getLogger(__name__)

# Initialize Flask app
app = Flask(__name__)

# Config file path
config_file = os.environ.get('CONFIG_FILE', 'config.yaml')
logger.info(f"Using config file: {config_file}")

# Load configuration
try:
    with open(config_file, 'r') as f:
        config = yaml.safe_load(f)
    logger.info(f"Configuration loaded successfully from {config_file}")
except Exception as e:
    logger.error(f"Failed to load configuration: {e}")
    config = {}

# Initialize SlackNotifier
slack_notifier = SlackNotifier(config_file=config_file)

# Initialize CiscoDeviceManager with proper parameters
cisco_manager = CiscoDeviceManager(
    username=config.get('ciscoUsername', ''),
    password=config.get('ciscoPassword', ''),
    timeout=config.get('timeout', DEFAULT_TIMEOUT)
)

# Configuration is already loaded above
# Using the imported CiscoDeviceManager instead of defining a custom class

# Using SlackNotifier to send responses back to Slack
# The post_update_to_slack method replaces the send_slack_response function

def verify_slack_request(request_data, timestamp, signature):
    """Verify the request is coming from Slack."""
    if not SLACK_VERIFY_TOKEN:
        return True  # Skip verification if token not configured
    
    # This is a very basic verification method
    # For production use, implement proper Slack signing secret verification
    try:
        body = request_data.decode('utf-8')
        if "token" in body and f"token={SLACK_VERIFY_TOKEN}" in body:
            return True
    except:
        pass
    
    return False

@app.route('/slack/actions', methods=['POST'])
def slack_actions():
    """Handle Slack interactive button actions."""
    # Get request data
    request_body = request.get_data()
    timestamp = request.headers.get('X-Slack-Request-Timestamp', '')
    signature = request.headers.get('X-Slack-Signature', '')
    
    # Verify request is from Slack (basic verification)
    if not verify_slack_request(request_body, timestamp, signature):
        logger.warning("Failed to verify Slack request")
        return Response("Verification failed", status=403)
    
    # Parse the request payload
    try:
        form_data = request.form
        payload_str = form_data.get('payload', '{}')
        payload = json.loads(payload_str)
        
        # Extract action data
        actions = payload.get('actions', [])
        if not actions:
            return Response("No action found", status=400)
            
        action = actions[0]
        action_id = action.get('action_id', '')
        action_value = action.get('value', '')
        
        # Get callback URL for responding to Slack
        response_url = payload.get('response_url', '')
        
        # Parse the action value (expected format: "device|interface")
        if '|' not in action_value:
            logger.error(f"Invalid action value format: {action_value}")
            slack_notifier.post_update_to_slack(response_url, "Invalid action format", success=False)
            return Response("Invalid action format", status=400)
            
        device, interface = action_value.split('|', 1)
        
    except Exception as e:
        logger.error(f"Error parsing Slack payload: {e}")
        return Response(f"Error: {str(e)}", status=400)
    
    # Process the action
    if action_id == "fix_interface":
        return handle_fix_interface(device, interface, response_url)
    
    return Response("Unknown action", status=400)

def handle_fix_interface(device, interface, response_url):
    """Handle the 'fix interface' button action."""
    logger.info(f"Received request to fix interface {interface} on device {device}")
    
    # Send immediate acknowledgement
    slack_notifier.post_update_to_slack(
        response_url,
        f"Attempting to bring up interface {interface} on {device}...",
        success=True,
        replace_original=False
    )
    
    # Connect to the device and bring up the interface
    if not config:
        logger.error("Configuration not loaded")
        slack_notifier.post_update_to_slack(
            response_url,
            f"Failed to bring up interface {interface}: Configuration error",
            success=False
        )
        return Response("Configuration error", status=500)
    
    # Using the already initialized cisco_manager
    
    try:
        # Connect to the device and bring interface up
        result = cisco_manager.bring_interface_up(device, interface)
        
        if result:
            logger.info(f"Successfully brought up interface {interface} on {device}")
            slack_notifier.post_update_to_slack(
                response_url,
                f"✅ Successfully brought up interface {interface} on {device}",
                success=True
            )
        else:
            logger.error(f"Failed to bring up interface {interface} on {device}")
            slack_notifier.post_update_to_slack(
                response_url,
                f"Failed to bring up interface {interface} on {device}",
                success=False
            )
        
    except Exception as e:
        logger.error(f"Error processing request: {e}")
        slack_notifier.post_update_to_slack(
            response_url,
            f"Error processing request: {str(e)}",
            success=False
        )
        return Response(f"Error: {str(e)}", status=500)
    
    return Response("Processing", status=200)

if __name__ == "__main__":
    # Check if config loaded successfully
    if not config:
        logger.error("Failed to load configuration. Exiting.")
        sys.exit(1)
    
    # Display loaded configuration (omitting sensitive data)
    logger.info(f"Loaded configuration from {config_file}")
    logger.info(f"Interactive buttons enabled: {config.get('use_interactive_buttons', False)}")
    logger.info(f"Using ngrok URL: {config.get('ngrok_url', 'Not set')}")
    
    # Verify critical configuration
    if not config.get('use_interactive_buttons', False):
        logger.warning("Interactive buttons are disabled in config. This server may not receive callbacks.")
    
    if not config.get('ngrok_url'):
        logger.warning("No ngrok URL set in config. Slack interactive buttons will not work properly.")
    
    # Start the Flask server    
    port = int(os.environ.get("PORT", 8080))
    debug = os.environ.get("FLASK_DEBUG", "0") == "1"
    
    logger.info(f"Starting Slack Interactive Button Server on port {port}")
    logger.info(f"Server will be accessible via ngrok at {config.get('ngrok_url', 'unknown URL')}/slack/actions")
    app.run(host='0.0.0.0', port=port, debug=debug)
</file>

<file path="slack-app-manifest.yaml">
display_information:
  name: LogZilla Network Monitor
  description: Monitor and manage network interfaces through interactive Slack notifications
  background_color: "#9C1A22"

features:
  bot_user:
    display_name: LogZilla Bot
    always_online: true

oauth_config:
  scopes:
    bot:
      - chat:write
      - incoming-webhook
      - commands

settings:
  interactivity:
    is_enabled: true
    request_url: "https://logzilla.ngrok.io/slack/actions"
  org_deploy_enabled: false
  socket_mode_enabled: false
  token_rotation_enabled: false
</file>

<file path="update_ngrok_url.sh">
#!/bin/bash
# Script to extract the ngrok URL and update the compliance.yaml file

CONFIG_FILE="/root/lz-compliance/config.yaml"
NGROK_LOG="/var/log/ngrok.log"
MAX_ATTEMPTS=30
SLEEP_INTERVAL=2

echo "Waiting for ngrok to generate a public URL..."

# Initialize attempt counter
attempt=0

# Wait for ngrok to start and get the URL
while [ $attempt -lt $MAX_ATTEMPTS ]; do
    # Check if ngrok is running
    if ! docker ps | grep -q ngrok; then
        echo "Ngrok container is not running. Please start it first."
        exit 1
    fi

    # Get ngrok URL from container logs - for custom domain
    NGROK_URL=$(docker logs ngrok 2>&1 | grep -o "https://logzilla.ngrok.io" | head -n1)
    
    # If custom domain not found, try standard domain pattern as fallback
    if [ -z "$NGROK_URL" ]; then
        NGROK_URL=$(docker logs ngrok 2>&1 | grep -o "https://.*\.ngrok-free\.app\|https://.*\.ngrok\.io" | head -n1)
    fi
    
    if [ -n "$NGROK_URL" ]; then
        echo "Found ngrok URL: $NGROK_URL"
        
        # Make sure the URL ends with a slash
        if [[ ! "$NGROK_URL" == */ ]]; then
            NGROK_URL="${NGROK_URL}/"
        fi
        
        # Update the compliance.yaml file
        if [ -f "$CONFIG_FILE" ]; then
            sed -i "s|ngrok_url:.*|ngrok_url: \"$NGROK_URL\"|g" "$CONFIG_FILE"
            echo "Updated $CONFIG_FILE with the new ngrok URL"
            echo "Your Slack interactive buttons will now use: $NGROK_URL"
            exit 0
        else
            echo "Error: Config file $CONFIG_FILE not found"
            exit 1
        fi
    fi
    
    echo "Waiting for ngrok URL to be available (attempt $((attempt+1))/$MAX_ATTEMPTS)..."
    attempt=$((attempt+1))
    sleep $SLEEP_INTERVAL
done

echo "Error: Failed to get ngrok URL after $MAX_ATTEMPTS attempts"
exit 1
</file>

<file path="utils.py">
#!/usr/bin/env python3
"""
Utility modules for LogZilla Network Event Orchestrator.

Provides utility classes for logging, configuration loading, and network operations.
"""

import os
import sys
import yaml
import socket
import logging
import ipaddress
import urllib3

# Constants
REQUIRED_CONFIG_KEYS = ["ciscoUsername", "ciscoPassword", "posturl"]

class LoggingConfigurator:
    """Configure logging settings for the application."""
    
    @staticmethod
    def setup_logging():
        """Set up logging to stdout/stderr with level from environment variable."""
        # Get log level from environment variable or default to INFO
        log_level_name = os.environ.get('LOG_LEVEL', 'INFO')
        log_level = getattr(logging, log_level_name.upper(), logging.INFO)
        
        # Configure root logger
        logging.basicConfig(
            level=log_level,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        
        # Set third-party loggers to a higher level to reduce noise
        logging.getLogger('paramiko').setLevel(logging.WARNING)
        logging.getLogger('netmiko').setLevel(logging.WARNING)
        logging.getLogger('urllib3').setLevel(logging.WARNING)
        
        # Suppress InsecureRequestWarning for Slack API calls with proper verification
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
        
        logging.debug(f"Log level set to: {log_level_name}")


class ConfigLoader:
    """Load and validate configuration from YAML files."""
    
    @staticmethod
    def load_config(config_file):
        """
        Load configuration from a YAML file.
        
        Args:
            config_file (str): Path to the YAML configuration file.
            
        Returns:
            dict: Configuration as a dictionary.
            
        Raises:
            SystemExit: If the file is not found, contains invalid YAML,
                or is missing required configuration keys.
        """
        try:
            with open(config_file, 'r') as file:
                config = yaml.safe_load(file)
                
            # Validate required configuration keys
            missing_keys = [key for key in REQUIRED_CONFIG_KEYS if key not in config]
            if missing_keys:
                logging.error(f"Missing required configuration keys: {', '.join(missing_keys)}")
                sys.exit(1)
                
            return config
        except FileNotFoundError:
            logging.error(f"Configuration file {config_file} not found.")
            sys.exit(1)
        except yaml.YAMLError as e:
            logging.error(f"Error parsing configuration file: {e}")
            sys.exit(1)


class NetworkUtils:
    """Network-related utility functions."""
    
    @staticmethod
    def is_valid_ip(ip_string):
        """
        Check if a string is a valid IP address.
        
        Args:
            ip_string (str): The string to check.
            
        Returns:
            bool: True if the string is a valid IP address, False otherwise.
        """
        try:
            ipaddress.ip_address(ip_string)
            return True
        except ValueError:
            return False
    
    @staticmethod
    def resolve_host(hostname, config):
        """
        Resolve hostname to IP address.
        
        Args:
            hostname (str): Hostname to resolve.
            config (dict): Configuration dictionary that may contain a fallback IP.
            
        Returns:
            str: IP address if resolution is successful.
            
        Raises:
            SystemExit: If resolution fails and no fallback IP is available.
        """
        # If hostname is already an IP, return it
        if NetworkUtils.is_valid_ip(hostname):
            logging.debug(f"{hostname} is already an IP address")
            return hostname
        
        # Try to resolve hostname
        try:
            logging.debug(f"Attempting to resolve hostname: {hostname}")
            ip = socket.gethostbyname(hostname)
            logging.debug(f"Resolved {hostname} to {ip}")
            return ip
        except socket.gaierror as e:
            logging.error(f"Unable to resolve {hostname}: {str(e)}")
            
            # Check if fallback IP is available
            fallback_ip = config.get('fallback_ip')
            if fallback_ip:
                logging.warning(f"Using fallback IP address: {fallback_ip}")
                return fallback_ip
            
            logging.error("No fallback IP available - cannot continue")
            sys.exit(1)
</file>

</files>
